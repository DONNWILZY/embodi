{
    "rewrites": [{ "source": "/(.*)", "destination": "/api" }]
  }

  
  {
    "version": 2,
    "builds": [
        {
            "src": "/index.js",
            "use": "@vercel/node"
        }
    ],
    "routes": [
        {
          "src": "/(.*)",
          "dest": "/"
        }
    ]
    
}

/* ///////// NOT IN USE
const generateOTPCode = () => {
    const digits = '0123456789';
    let otpCode = '';
    for (let i = 0; i < 6; i++) {
      otpCode += digits[Math.floor(Math.random() * 10)];
    }
    return otpCode;
  };
  
  const registerUser = async (req, res) => {

    const { firstName, lastName, phoneNumber, email, password } = req.body;
  
    // Check if any of the fields are empty
    if (!firstName || !lastName || !phoneNumber || !email || !password) {
      return res.status(400).json({
        status: 'failed',
        message: 'Fields cannot be blank',
      });
    }
  
    // Password requirements
    const passwordRegex = /^(?=.*?[A-Z])(?=.*?[a-z])(?=.*?[0-9])(?=.*?[!@#$%^&*]).{8,}$/;
    if (!passwordRegex.test(password)) {
      return res.status(400).json({
        status: 'failed',
        message:
          'Password must be at least 8 characters long, contain an uppercase letter, a lowercase letter, and a special character.',
      });
    }
  
    try {
      const existingUser = await User.findOne({ $or: [{ phoneNumber }, { email }] });
  
      if (existingUser) {
        return res.status(400).json({
          status: 'failed',
          message: 'Email or Phone is already in use.',
        });
      }
  
      const salt = await bcrypt.genSalt(10);
      const hashedPassword = await bcrypt.hash(password, salt);
  
      const newUser = new User({
        firstName,
        lastName,
        phoneNumber,
        email,
        password: hashedPassword,
      });
  
      const savedUser = await newUser.save();
  
      // Send verification OTP
    const otpCode = generateOTPCode();

    // Set the expiration time to 10 minutes from now
    const expirationTime = new Date(Date.now() + 10 * 60 * 1000);

    const otpCodeRecord = new OTPCode({
      userId: savedUser._id,
      code: otpCode,
      createdAt: Date.now(),
      expiresAt: expirationTime, // Set the expiration time here
    });
    await otpCodeRecord.save();

    
  
    // You can send the OTP to the user's email here if needed
    const mailOptions = {
      from: process.env.AUTH_EMAIL,
      to: savedUser.email, // Use savedUser.email instead of User.email
      subject: 'Verify Your Email',
      html: `
        <h1>Email Verification</h1>
        <p><strong>${otpCode}</strong></p>
        <p>Please enter the verification code in your account settings to verify your email.</p>
      `,
    };

    transporter.sendMail(mailOptions, (error, info) => {
      if (error) {
        console.log(error);
      } else {
        console.log('Email sent: ' + info.response);
      }
    });

    return res.status(200).json({
      status: 'success',
      message: 'Signup successful. Please verify your email using the OTP.',
    });
  } catch (error) {
    console.log(error);
    return res.status(500).json({
      status: 'failed',
      message: 'An error occurred while signing up.',
    });
  }



  
  
};

*/
/* //////////////////////// OLD CODE HERE
const generateOTPCode = () => {
    const digits = '0123456789';
    let otpCode = '';
    for (let i = 0; i < 6; i++) {
      otpCode += digits[Math.floor(Math.random() * 10)];
    }
    return otpCode;
  };
  
  
  const registerUser = async (req, res) => {
    const { firstName, lastName, phoneNumber, email, password } = req.body;
  
    // Check if any of the fields are empty
    if (!firstName || !lastName || !phoneNumber || !email || !password) {
      return res.status(400).json({
        status: 'failed',
        message: 'Fields cannot be blank',
      });
    }
  
    // Password requirements
    const passwordRegex = /^(?=.*?[A-Z])(?=.*?[a-z])(?=.*?[0-9])(?=.*?[!@#$%^&*]).{8,}$/;
    if (!passwordRegex.test(password)) {
      return res.status(400).json({
        status: 'failed',
        message:
          'Password must be at least 8 characters long, contain an uppercase letter, a lowercase letter, and a special character.',
      });
    }
  
    try {
      // Check if the email or phone number is already in use
      const existingUser = await User.findOne({ $or: [{ phoneNumber }, { email }] });
  
      if (existingUser) {
        // Check if the existing user is unverified
        if (!existingUser.verified) {
          // Regenerate a new OTP for the existing unverified user
          const otpCode = generateOTPCode();
          const expirationTime = new Date(Date.now() + 10 * 60 * 1000);
  
          // Update the existing OTP code record
          await OTPCode.updateOne(
            { userId: existingUser._id },
            { code: otpCode, createdAt: Date.now(), expiresAt: expirationTime }
          );
  
          // Resend the OTP to the user's email
          const mailOptions = {
            from: process.env.AUTH_EMAIL,
            to: existingUser.email,
            subject: 'Verify Your Email',
            html: `
              <h1>Email Verification</h1>
              <p><strong>${otpCode}</strong></p>
              <p>Please enter the verification code in your account settings to verify your email.</p>
            `,
          };
  
          transporter.sendMail(mailOptions, (error, info) => {
            if (error) {
              console.log(error);
            } else {
              console.log('Email sent: ' + info.response);
            }
          });
  
          return res.status(200).json({
            status: 'success',
            message: 'Verification code has been resent. Please check your email.',
          });
        } else {
          // User already exists and is verified
          return res.status(400).json({
            status: 'failed',
            message: 'Email or Phone is already in use.',
          });
        }
      }
  
      // If the user does not exist, proceed with the normal sign-up process
  
      const saltRounds = 10;
      const hashedPassword = await bcrypt.hash(password, saltRounds);
  
      // Save the new user record
      const newUser = new User({
        firstName,
        lastName,
        phoneNumber,
        email,
        password: hashedPassword,
      });
  
      const savedUser = await newUser.save();
  
      // ... (send verification OTP and other actions) ...
  
      return res.status(200).json({
        status: 'success',
        message: 'Signup successful. Please verify your email using the OTP.',
      });
    } catch (error) {
      console.log(error);
      return res.status(500).json({
        status: 'failed',
        message: 'An error occurred while signing up.',
      });
    }
  };
  
*/


/*
// Function to create a new appointment
const createAppointment = async (req, res) => {
  const { doctorId, patientId, startTime, endTime, date } = req.body;

  try {
    // Check if the doctor and patient exist
    const doctor = await Doctor.findById(doctorId);
    const patient = await User.findById(patientId);

    if (!doctor || !patient) {
      return res.status(404).json({
        status: 'failed',
        message: 'Doctor or patient not found. Please enter valid IDs.',
      });
    }

    // Check if the doctor has the requested time slot available
    const isAvailable = doctor.availableTimeSlots.some(
      (slot) => slot.startTime === startTime && slot.endTime === endTime
    );

    if (!isAvailable) {
      return res.status(400).json({
        status: 'failed',
        message: 'The requested time slot is not available for this doctor.',
      });
    }

    // Create the new appointment
    const newAppointment = new Appointment({
      doctor: doctorId,
      patient: patientId,
      startTime,
      endTime,
      date,
    });

    const savedAppointment = await newAppointment.save();

    // Send email to confirm appointment creation
    const mailOptions = {
      from: process.env.AUTH_EMAIL,
      to: patient.email,
      subject: 'Appointment Confirmation',
      html: `
        <h1>Appointment Confirmation</h1>
        <p>Your appointment with Dr. ${doctor.firstName} ${doctor.lastName} has been scheduled for ${date} from ${startTime} to ${endTime}.</p>
      `,
    };

    transporter.sendMail(mailOptions, (error, info) => {
      if (error) {
        console.log(error);
      } else {
        console.log('Email sent: ' + info.response);
      }
    });

    return res.status(200).json({
      status: 'success',
      message: 'Appointment created successfully.',
      data: savedAppointment,
    });
  } catch (error) {
    console.log(error);
    return res.status(500).json({
      status: 'failed',
      message: 'An error occurred while creating the appointment.',
    });
  }
};

// Function to update an existing appointment
const updateAppointment = async (req, res) => {
  const { appointmentId } = req.params;
  const { startTime, endTime, date } = req.body;

  try {
    // Check if the appointment exists
    const appointment = await Appointment.findById(appointmentId);

    if (!appointment) {
      return res.status(404).json({
        status: 'failed',
        message: 'Appointment not found. Please enter a valid appointmentId.',
      });
    }

    // Update the appointment
    appointment.startTime = startTime;
    appointment.endTime = endTime;
    appointment.date = date;
    const updatedAppointment = await appointment.save();

    return res.status(200).json({
      status: 'success',
      message: 'Appointment updated successfully.',
      data: updatedAppointment,
    });
  } catch (error) {
    console.log(error);
    return res.status(500).json({
      status: 'failed',
      message: 'An error occurred while updating the appointment.',
    });
  }
};

// Function to delete an existing appointment
const deleteAppointment = async (req, res) => {
  const { appointmentId } = req.params;

  try {
    // Check if the appointment exists
    const appointment = await Appointment.findById(appointmentId);

    if (!appointment) {
      return res.status(404).json({
        status: 'failed',
        message: 'Appointment not found. Please enter a valid appointmentId.',
      });
    }

    // Delete the appointment
    await appointment.remove();

    return res.status(200).json({
      status: 'success',
      message: 'Appointment deleted successfully.',
    });
  } catch (error) {
    console.log(error);
    return res.status(500).json({
      status: 'failed',
      message: 'An error occurred while deleting the appointment.',
    });
  }
};

// Function to view all appointments
const viewAppointments = async (req, res) => {
  try {
    const appointments = await Appointment.find();
    return res.status(200).json({
      status: 'success',
      message: 'Appointments retrieved successfully.',
      data: appointments,
    });
  } catch (error) {
    console.log(error);
    return res.status(500).json({
      status: 'failed',
      message: 'An error occurred while fetching the appointments.',
    });
  }
};
*/
// Function to create a new appointment



/*
const createAppointment = async (req, res) => {
    const { doctorId, patientId, startTime, endTime, date } = req.body;
  
    try {
      // Check if the doctor exists
      const doctor = await Doctor.findById(doctorId);
  
      if (!doctor) {
        return res.status(404).json({
          status: 'failed',
          message: 'Doctor not found. Please enter a valid doctorId.',
        });
      }
  
      // Get the list of available time slots for the doctor
      const availableTimeSlots = doctor.availableTimeSlots;
  
      if (!availableTimeSlots.some(
        (slot) => slot.startTime === startTime && slot.endTime === endTime
      )) {
        return res.status(400).json({
          status: 'failed',
          message: 'The requested time slot is not available for this doctor.',
        });
      }
  
      // Create the new appointment
      const newAppointment = new Appointment({
        doctor,
        patientId,
        startTime,
        endTime,
        date,
      });
  
      const savedAppointment = await newAppointment.save();
  
      // Send email to doctor to confirm appointment creation
      const doctorMailOptions = {
        from: process.env.AUTH_EMAIL,
        to: doctor.email,
        subject: 'Appointment Created',
        html: `
          <h1>Appointment Created</h1>
          <p>You have created an appointment with patient ${patientId} on ${date} from ${startTime} to ${endTime}.</p>
        `,
      };
  
      // Send email to patient to confirm appointment creation
      const patientMailOptions = {
        from: process.env.AUTH_EMAIL,
        to: patientId, // Assuming patientId contains the patient's email address
        subject: 'Appointment Created',
        html: `
          <h1>Appointment Created</h1>
          <p>You have successfully booked an appointment with ${doctor.name} on ${date} from ${startTime} to ${endTime}.</p>
        `,
      };
  
      transporter.sendMail(doctorMailOptions, (error, info) => {
        if (error) {
          console.log(error);
        } else {
          console.log('Doctor email sent: ' + info.response);
        }
      });
  
      transporter.sendMail(patientMailOptions, (error, info) => {
        if (error) {
          console.log(error);
        } else {
          console.log('Patient email sent: ' + info.response);
        }
      });
  
      return res.status(200).json({
        status: 'success',
        message: 'Appointment created successfully.',
        data: savedAppointment,
      });
    } catch (error) {
      console.log(error);
      return res.status(500).json({
        status: 'failed',
        message: 'An error occurred while creating the appointment.',
      });
    }
  };

  */
  


/*
const createAppointment = async (req, res) => {
    const { doctorId, patientId, startTime, endTime, date } = req.body;
  
    try {
      // Check if the doctor exists
      const doctor = await Doctor.findById(doctorId);
  
      if (!doctor) {
        return res.status(404).json({
          status: 'failed',
          message: 'Doctor not found. Please enter a valid doctorId.',
        });
      }
  
      // Get the list of available time slots for the doctor
      const availableTimeSlots = doctor.availableTimeSlots;
  
      if (!availableTimeSlots.some(
        (slot) => slot.startTime === startTime && slot.endTime === endTime
      )) {
        return res.status(400).json({
          status: 'failed',
          message: 'The requested time slot is not available for this doctor.',
        });
      }
  
      // Create the new appointment
      const newAppointment = new Appointment({
        doctor,
        patientId,
        startTime,
        endTime,
        date,
      });
  
      const savedAppointment = await newAppointment.save();
  
      // Send email to confirm appointment creation
      const mailOptions = {
        from: process.env.AUTH_EMAIL,
        to: doctor.email,
        subject: 'Appointment Created',
        html: `
          <h1>Appointment Created</h1>
          <p>You have created an appointment with patient ${patientId} for ${date} from ${startTime} to ${endTime}.</p>
        `,
      };
  
      transporter.sendMail(mailOptions, (error, info) => {
        if (error) {
          console.log(error);
        } else {
          console.log('Email sent: ' + info.response);
        }
      });
  
      return res.status(200).json({
        status: 'success',
        message: 'Appointment created successfully.',
        data: savedAppointment,
      });
    } catch (error) {
      console.log(error);
      return res.status(500).json({
        status: 'failed',
        message: 'An error occurred while creating the appointment.',
      });
    }
  };
*/