''  '''''''''''''''''''''''''''''''                                                                                                                                                                                              ' {
    "rewrites": [{ "source": "/(.*)", "destination": "/api" }]
  }

  
  {
    "version": 2,
    "builds": [
        {
            "src": "/index.js",
            "use": "@vercel/node"
        }
    ],
    "routes": [
        {
          "src": "/(.*)",
          "dest": "/"
        }
    ]
    
}

/* ///////// NOT IN USE //////registerUser
const generateOTPCode = () => {
    const digits = '0123456789';
    let otpCode = '';
    for (let i = 0; i < 6; i++) {
      otpCode += digits[Math.floor(Math.random() * 10)];
    }
    return otpCode;
  };
  
  const registerUser = async (req, res) => {

    const { firstName, lastName, phoneNumber, email, password } = req.body;
  
    // Check if any of the fields are empty
    if (!firstName || !lastName || !phoneNumber || !email || !password) {
      return res.status(400).json({
        status: 'failed',
        message: 'Fields cannot be blank',
      });
    }
  
    // Password requirements
    const passwordRegex = /^(?=.*?[A-Z])(?=.*?[a-z])(?=.*?[0-9])(?=.*?[!@#$%^&*]).{8,}$/;
    if (!passwordRegex.test(password)) {
      return res.status(400).json({
        status: 'failed',
        message:
          'Password must be at least 8 characters long, contain an uppercase letter, a lowercase letter, and a special character.',
      });
    }
  
    try {
      const existingUser = await User.findOne({ $or: [{ phoneNumber }, { email }] });
  
      if (existingUser) {
        return res.status(400).json({
          status: 'failed',
          message: 'Email or Phone is already in use.',
        });
      }
  
      const salt = await bcrypt.genSalt(10);
      const hashedPassword = await bcrypt.hash(password, salt);
  
      const newUser = new User({
        firstName,
        lastName,
        phoneNumber,
        email,
        password: hashedPassword,
      });
  
      const savedUser = await newUser.save();
  
      // Send verification OTP
    const otpCode = generateOTPCode();

    // Set the expiration time to 10 minutes from now
    const expirationTime = new Date(Date.now() + 10 * 60 * 1000);

    const otpCodeRecord = new OTPCode({
      userId: savedUser._id,
      code: otpCode,
      createdAt: Date.now(),
      expiresAt: expirationTime, // Set the expiration time here
    });
    await otpCodeRecord.save();

    
  
    // You can send the OTP to the user's email here if needed
    const mailOptions = {
      from: process.env.AUTH_EMAIL,
      to: savedUser.email, // Use savedUser.email instead of User.email
      subject: 'Verify Your Email',
      html: `
        <h1>Email Verification</h1>
        <p><strong>${otpCode}</strong></p>
        <p>Please enter the verification code in your account settings to verify your email.</p>
      `,
    };

    transporter.sendMail(mailOptions, (error, info) => {
      if (error) {
        console.log(error);
      } else {
        console.log('Email sent: ' + info.response);
      }
    });

    return res.status(200).json({
      status: 'success',
      message: 'Signup successful. Please verify your email using the OTP.',
    });
  } catch (error) {
    console.log(error);
    return res.status(500).json({
      status: 'failed',
      message: 'An error occurred while signing up.',
    });
  }



  
  
};

*/
/* //////////////////////// OLD CODE HERE
const generateOTPCode = () => {
    const digits = '0123456789';
    let otpCode = '';
    for (let i = 0; i < 6; i++) {
      otpCode += digits[Math.floor(Math.random() * 10)];
    }
    return otpCode;
  };
  
  
  const registerUser = async (req, res) => {
    const { firstName, lastName, phoneNumber, email, password } = req.body;
  
    // Check if any of the fields are empty
    if (!firstName || !lastName || !phoneNumber || !email || !password) {
      return res.status(400).json({
        status: 'failed',
        message: 'Fields cannot be blank',
      });
    }
  
    // Password requirements
    const passwordRegex = /^(?=.*?[A-Z])(?=.*?[a-z])(?=.*?[0-9])(?=.*?[!@#$%^&*]).{8,}$/;
    if (!passwordRegex.test(password)) {
      return res.status(400).json({
        status: 'failed',
        message:
          'Password must be at least 8 characters long, contain an uppercase letter, a lowercase letter, and a special character.',
      });
    }
  
    try {
      // Check if the email or phone number is already in use
      const existingUser = await User.findOne({ $or: [{ phoneNumber }, { email }] });
  
      if (existingUser) {
        // Check if the existing user is unverified
        if (!existingUser.verified) {
          // Regenerate a new OTP for the existing unverified user
          const otpCode = generateOTPCode();
          const expirationTime = new Date(Date.now() + 10 * 60 * 1000);
  
          // Update the existing OTP code record
          await OTPCode.updateOne(
            { userId: existingUser._id },
            { code: otpCode, createdAt: Date.now(), expiresAt: expirationTime }
          );
  
          // Resend the OTP to the user's email
          const mailOptions = {
            from: process.env.AUTH_EMAIL,
            to: existingUser.email,
            subject: 'Verify Your Email',
            html: `
              <h1>Email Verification</h1>
              <p><strong>${otpCode}</strong></p>
              <p>Please enter the verification code in your account settings to verify your email.</p>
            `,
          };
  
          transporter.sendMail(mailOptions, (error, info) => {
            if (error) {
              console.log(error);
            } else {
              console.log('Email sent: ' + info.response);
            }
          });
  
          return res.status(200).json({
            status: 'success',
            message: 'Verification code has been resent. Please check your email.',
          });
        } else {
          // User already exists and is verified
          return res.status(400).json({
            status: 'failed',
            message: 'Email or Phone is already in use.',
          });
        }
      }
  
      // If the user does not exist, proceed with the normal sign-up process
  
      const saltRounds = 10;
      const hashedPassword = await bcrypt.hash(password, saltRounds);
  
      // Save the new user record
      const newUser = new User({
        firstName,
        lastName,
        phoneNumber,
        email,
        password: hashedPassword,
      });
  
      const savedUser = await newUser.save();
  
      // ... (send verification OTP and other actions) ...
  
      return res.status(200).json({
        status: 'success',
        message: 'Signup successful. Please verify your email using the OTP.',
      });
    } catch (error) {
      console.log(error);
      return res.status(500).json({
        status: 'failed',
        message: 'An error occurred while signing up.',
      });
    }
  };
  
*/


/*
// Function to create a new appointment
const createAppointment = async (req, res) => {
  const { doctorId, patientId, startTime, endTime, date } = req.body;

  try {
    // Check if the doctor and patient exist
    const doctor = await Doctor.findById(doctorId);
    const patient = await User.findById(patientId);

    if (!doctor || !patient) {
      return res.status(404).json({
        status: 'failed',
        message: 'Doctor or patient not found. Please enter valid IDs.',
      });
    }

    // Check if the doctor has the requested time slot available
    const isAvailable = doctor.availableTimeSlots.some(
      (slot) => slot.startTime === startTime && slot.endTime === endTime
    );

    if (!isAvailable) {
      return res.status(400).json({
        status: 'failed',
        message: 'The requested time slot is not available for this doctor.',
      });
    }

    // Create the new appointment
    const newAppointment = new Appointment({
      doctor: doctorId,
      patient: patientId,
      startTime,
      endTime,
      date,
    });

    const savedAppointment = await newAppointment.save();

    // Send email to confirm appointment creation
    const mailOptions = {
      from: process.env.AUTH_EMAIL,
      to: patient.email,
      subject: 'Appointment Confirmation',
      html: `
        <h1>Appointment Confirmation</h1>
        <p>Your appointment with Dr. ${doctor.firstName} ${doctor.lastName} has been scheduled for ${date} from ${startTime} to ${endTime}.</p>
      `,
    };

    transporter.sendMail(mailOptions, (error, info) => {
      if (error) {
        console.log(error);
      } else {
        console.log('Email sent: ' + info.response);
      }
    });

    return res.status(200).json({
      status: 'success',
      message: 'Appointment created successfully.',
      data: savedAppointment,
    });
  } catch (error) {
    console.log(error);
    return res.status(500).json({
      status: 'failed',
      message: 'An error occurred while creating the appointment.',
    });
  }
};

// Function to update an existing appointment
const updateAppointment = async (req, res) => {
  const { appointmentId } = req.params;
  const { startTime, endTime, date } = req.body;

  try {
    // Check if the appointment exists
    const appointment = await Appointment.findById(appointmentId);

    if (!appointment) {
      return res.status(404).json({
        status: 'failed',
        message: 'Appointment not found. Please enter a valid appointmentId.',
      });
    }

    // Update the appointment
    appointment.startTime = startTime;
    appointment.endTime = endTime;
    appointment.date = date;
    const updatedAppointment = await appointment.save();

    return res.status(200).json({
      status: 'success',
      message: 'Appointment updated successfully.',
      data: updatedAppointment,
    });
  } catch (error) {
    console.log(error);
    return res.status(500).json({
      status: 'failed',
      message: 'An error occurred while updating the appointment.',
    });
  }
};

// Function to delete an existing appointment
const deleteAppointment = async (req, res) => {
  const { appointmentId } = req.params;

  try {
    // Check if the appointment exists
    const appointment = await Appointment.findById(appointmentId);

    if (!appointment) {
      return res.status(404).json({
        status: 'failed',
        message: 'Appointment not found. Please enter a valid appointmentId.',
      });
    }

    // Delete the appointment
    await appointment.remove();

    return res.status(200).json({
      status: 'success',
      message: 'Appointment deleted successfully.',
    });
  } catch (error) {
    console.log(error);
    return res.status(500).json({
      status: 'failed',
      message: 'An error occurred while deleting the appointment.',
    });
  }
};

// Function to view all appointments
const viewAppointments = async (req, res) => {
  try {
    const appointments = await Appointment.find();
    return res.status(200).json({
      status: 'success',
      message: 'Appointments retrieved successfully.',
      data: appointments,
    });
  } catch (error) {
    console.log(error);
    return res.status(500).json({
      status: 'failed',
      message: 'An error occurred while fetching the appointments.',
    });
  }
};
*/
// Function to create a new appointment



/*
const createAppointment = async (req, res) => {
    const { doctorId, patientId, startTime, endTime, date } = req.body;
  
    try {
      // Check if the doctor exists
      const doctor = await Doctor.findById(doctorId);
  
      if (!doctor) {
        return res.status(404).json({
          status: 'failed',
          message: 'Doctor not found. Please enter a valid doctorId.',
        });
      }
  
      // Get the list of available time slots for the doctor
      const availableTimeSlots = doctor.availableTimeSlots;
  
      if (!availableTimeSlots.some(
        (slot) => slot.startTime === startTime && slot.endTime === endTime
      )) {
        return res.status(400).json({
          status: 'failed',
          message: 'The requested time slot is not available for this doctor.',
        });
      }
  
      // Create the new appointment
      const newAppointment = new Appointment({
        doctor,
        patientId,
        startTime,
        endTime,
        date,
      });
  
      const savedAppointment = await newAppointment.save();
  
      // Send email to doctor to confirm appointment creation
      const doctorMailOptions = {
        from: process.env.AUTH_EMAIL,
        to: doctor.email,
        subject: 'Appointment Created',
        html: `
          <h1>Appointment Created</h1>
          <p>You have created an appointment with patient ${patientId} on ${date} from ${startTime} to ${endTime}.</p>
        `,
      };
  
      // Send email to patient to confirm appointment creation
      const patientMailOptions = {
        from: process.env.AUTH_EMAIL,
        to: patientId, // Assuming patientId contains the patient's email address
        subject: 'Appointment Created',
        html: `
          <h1>Appointment Created</h1>
          <p>You have successfully booked an appointment with ${doctor.name} on ${date} from ${startTime} to ${endTime}.</p>
        `,
      };
  
      transporter.sendMail(doctorMailOptions, (error, info) => {
        if (error) {
          console.log(error);
        } else {
          console.log('Doctor email sent: ' + info.response);
        }
      });
  
      transporter.sendMail(patientMailOptions, (error, info) => {
        if (error) {
          console.log(error);
        } else {
          console.log('Patient email sent: ' + info.response);
        }
      });
  
      return res.status(200).json({
        status: 'success',
        message: 'Appointment created successfully.',
        data: savedAppointment,
      });
    } catch (error) {
      console.log(error);
      return res.status(500).json({
        status: 'failed',
        message: 'An error occurred while creating the appointment.',
      });
    }
  };

  */
  


/*
const createAppointment = async (req, res) => {
    const { doctorId, patientId, startTime, endTime, date } = req.body;
  
    try {
      // Check if the doctor exists
      const doctor = await Doctor.findById(doctorId);
  
      if (!doctor) {
        return res.status(404).json({
          status: 'failed',
          message: 'Doctor not found. Please enter a valid doctorId.',
        });
      }
  
      // Get the list of available time slots for the doctor
      const availableTimeSlots = doctor.availableTimeSlots;
  
      if (!availableTimeSlots.some(
        (slot) => slot.startTime === startTime && slot.endTime === endTime
      )) {
        return res.status(400).json({
          status: 'failed',
          message: 'The requested time slot is not available for this doctor.',
        });
      }
  
      // Create the new appointment
      const newAppointment = new Appointment({
        doctor,
        patientId,
        startTime,
        endTime,
        date,
      });
  
      const savedAppointment = await newAppointment.save();
  
      // Send email to confirm appointment creation
      const mailOptions = {
        from: process.env.AUTH_EMAIL,
        to: doctor.email,
        subject: 'Appointment Created',
        html: `
          <h1>Appointment Created</h1>
          <p>You have created an appointment with patient ${patientId} for ${date} from ${startTime} to ${endTime}.</p>
        `,
      };
  
      transporter.sendMail(mailOptions, (error, info) => {
        if (error) {
          console.log(error);
        } else {
          console.log('Email sent: ' + info.response);
        }
      });
  
      return res.status(200).json({
        status: 'success',
        message: 'Appointment created successfully.',
        data: savedAppointment,
      });
    } catch (error) {
      console.log(error);
      return res.status(500).json({
        status: 'failed',
        message: 'An error occurred while creating the appointment.',
      });
    }
  };
*/


const User = require('../models/User');
const jwt = require('jsonwebtoken');
const transporter = require('../utilities/transporter');

const signUpAsDoctor = async (req, res) => {
  const { email, firstName, lastName, adminUserId } = req.body;

  try {
    // Check if the user making the request is an admin
    const adminUser = await User.findById(adminUserId);

    if (!adminUser || !adminUser.isAdmin) {
      return res.status(403).json({
        status: 'failed',
        message: 'You do not have permission to sign up doctors.',
      });
    }

    // Check if the user with the given email already exists
    let user = await User.findOne({ email });

    if (user) {
      // If the user exists, update their isDoctor field to true and save the user
      user.isDoctor = true;
      await user.save();

      // Send an email notifying the user that they are now a doctor
      const mailOptions = {
        from: 'Your Email <youremail@gmail.com>',
        to: email,
        subject: 'Congratulations! You are now a doctor',
        html: '<p>You have been verified as a doctor.</p>',
      };

      transporter.sendMail(mailOptions, (error, info) => {
        if (error) {
          console.log('Error sending verification email:', error);
        } else {
          console.log('Verification email sent:', info.response);
        }
      });

      return res.json({
        status: 200,
        message: 'Doctor created successfully.',
      });
    } else {
      // If the user does not exist, create a new user and set their isDoctor field to true
      const doctor = new User({
        email,
        firstName,
        lastName,
        isDoctor: true,
      });

      await doctor.save();

      // Generate a verification token and send it via email
      const verificationToken = jwt.sign(
        { email },
        'your_secret_verification_key', // Replace with your own secret key
        { expiresIn: '1h' }
      );

      const verificationLink = `http://yourdomain.com/verify-doctor?token=${verificationToken}`;

      const mailOptions = {
        from: 'Your Email <youremail@gmail.com>',
        to: email,
        subject: 'Verify Your Doctor Account',
        html: `<p>Please click the link below to verify your doctor account:</p><a href="${verificationLink}">${verificationLink}</a>`,
      };

      transporter.sendMail(mailOptions, (error, info) => {
        if (error) {
          console.log('Error sending verification email:', error);
        } else {
          console.log('Verification email sent:', info.response);
        }
      });

      return res.json({
        status: 200,
        message: 'Verification email sent. Please verify your doctor account.',
      });
    }
  } catch (error) {
    console.log('Error signing up as doctor:', error);
    return res.status(500).json({
      status: 'failed',
      message: 'An error occurred while processing your request.',
    });
  }
};

////////// this create user is working perfectly
const registerUser = async (req, res) => {
  const { firstName, lastName, phoneNumber, email, password } = req.body;

  if (!firstName || !lastName || !phoneNumber || !email || !password) {
    return res.status(400).json({
      status: 'failed',
      message: 'Fields cannot be blank',
    });
  }

  const passwordRegex = /^(?=.*?[A-Z])(?=.*?[a-z])(?=.*?[0-9])(?=.*?[!@#$%^&*]).{8,}$/;
  if (!passwordRegex.test(password)) {
    return res.status(400).json({
      status: 'failed',
      message: 'Password must be at least 8 characters long, contain an uppercase letter, a lowercase letter, and a special character.',
    });
  }

  try {
    // Check if the user with the given email already exists
    let user = await User.findOne({ email });

    if (user && !user.verified) {
      // If the user exists and is not verified, update their data and resend verification email
      user.firstName = firstName;
      user.lastName = lastName;
      user.phoneNumber = phoneNumber;
      user.password = await bcrypt.hash(password, 10); // Hash the new password
      await user.save();

      // Send OTP code to user's email
      const otpCode = generateOTPCode();

      // Set the expiration time to 10 minutes from now
      const expirationTime = new Date(Date.now() + 10 * 60 * 1000);

      // Save OTP code to database
      const otpCodeRecord = new OTPCode({
        userId: user._id,
        code: otpCode,
        createdAt: Date.now(),
        expiresAt: expirationTime,
      });
      await otpCodeRecord.save();

      // Prepare and send the email using the transporter and sendEmail function
      const mailOptions = {
        from: process.env.AUTH_EMAIL,
        to: user.email,
        subject: 'Verify Your Email',
        html: `
          <h1>Email Verification</h1>
          <p><strong>${otpCode}</strong></p>
          <p>Please enter the verification code in your account settings to verify your email.</p>
        `,
      };

      await transporter.sendMail(mailOptions);

      // Remove the password field from the response JSON
      const { password: removedPassword, ...userWithoutPassword } = user.toObject();

      return res.status(200).json({
        status: 'success',
        message: 'OTP sent to your email for verification.',
        user: userWithoutPassword,
      });
    } else if (user) {
      // If the user exists and is already verified, return an error message
      return res.status(400).json({
        status: 'failed',
        message: 'User already exists and is verified.',
      });
    }

    // If the user does not exist, create a new user and set their verified status to false
    const hashedPassword = await bcrypt.hash(password, 10); // 10 is the number of salt rounds
    const newUser = new User({
      firstName,
      lastName,
      phoneNumber,
      email,
      password: hashedPassword,
      verified: false,
    });

    const savedUser = await newUser.save();

    // Send OTP code to user's email
    const otpCode = generateOTPCode();

    // Set the expiration time to 10 minutes from now
    const expirationTime = new Date(Date.now() + 10 * 60 * 1000);

    // Save OTP code to database
    const otpCodeRecord = new OTPCode({
      userId: savedUser._id,
      code: otpCode,
      createdAt: Date.now(),
      expiresAt: expirationTime,
    });
    await otpCodeRecord.save();

    // Prepare and send the email using the transporter and sendEmail function
    const mailOptions = {
      from: process.env.AUTH_EMAIL,
      to: savedUser.email,
      subject: 'Verify Your Email',
      html: `
        <h1>Email Verification</h1>
        <p><strong>${otpCode}</strong></p>
        <p>Please enter the verification code in your account settings to verify your email.</p>
      `,
    };

    await transporter.sendMail(mailOptions);

    // Remove the password field from the response JSON
    const { password: removedPassword, ...userWithoutPassword } = savedUser.toObject();

    return res.status(200).json({
      status: 'success',
      message: 'OTP sent to your email for verification.',
      user: userWithoutPassword,
    });
  } catch (error) {
    console.log('Error while saving the user:', error);
    return res.status(500).json({
      status: 'failed',
      message: 'An error occurred while signing up. Kindly try again.',
    });
  }
};




//////////
/*
  const bookAppointment = async (req, res) => {
    const { appointmentId, patientId } = req.body;

    try {
      // Find the appointment to book
      const appointment = await Appointment.findById(appointmentId);

      // Check if the appointment exists
      if (!appointment) {
        return res.status(404).json({
          status: 'failed',
          message: 'Appointment not found. Please enter a valid appointmentId.',
        });
      }

      // Check if the patient ID already exists for the appointment
      if (appointment.patientId) {
        return res.status(400).json({
          status: 'failed',
          message: 'This appointment is already booked by another patient.',
        });
      }

      // Update the appointment with the patientId
      appointment.patientId = patientId;
      const bookedAppointment = await appointment.save();

      // Send email to doctor to notify about the appointment booking
      const doctorMailOptions = {
        from: process.env.AUTH_EMAIL,
        to: doctor.email,
        subject: 'Appointment Booked',
        html: `
          <h1>Appointment Booked</h1>
          <p>Patient ${patientId} has booked an appointment with you on ${appointment.date} from ${appointment.startTime} to ${appointment.endTime}.</p>
        `,
      };

      transporter.sendMail(doctorMailOptions, (error, info) => {
        if (error) {
          console.log(error);
        } else {
          console.log('Doctor email sent: ' + info.response);
        }
      });

      // Send email to patient to confirm appointment booking
      const patientMailOptions = {
        from: process.env.AUTH_EMAIL,
        to: patientId, // Assuming patientId contains the patient's email address
        subject: 'Appointment Booked',
        html: `
          <h1>Appointment Booked</h1>
          <p>You have successfully booked an appointment with Dr. ${appointment.doctor.name} on ${appointment.date} from ${appointment.startTime} to ${appointment.endTime}.</p>
        `,
      };

      transporter.sendMail(patientMailOptions, (error, info) => {
        if (error) {
          console.log(error);
        } else {
          console.log('Patient email sent: ' + info.response);
        }
      });

      return res.status(200).json({
        status: 'success',
        message: 'Appointment booked successfully.',
        data: bookedAppointment,
      });
    } catch (error) {
      console.log(error);
      return res.status(500).json({
        status: 'failed',
        message: 'An error occurred while booking the appointment.',
      });
    }
  };
*/



////// create disease.alt function
// Create a new disease
const createDiseases = async (req, res) => {
  try {
    const { title, category, photo, popular, detailTitle, detail } = req.body;

    const disease = new Disease({
      title,
      category,
      photo,
      popular,
      detailTitle,
      detail,
    });

    await disease.save();

    return res.status(201).json({
      status: 'success',
      message: 'Disease created successfully.',
      data: disease,
    });
  } catch (error) {
    console.log(error);
    return res.status(500).json({
      status: 'failed',
      message: 'An error occurred while creating the disease.',
    });
  }
};



/////fetch questionaire and diseses togther
const mongoose = require('mongoose');

const viewQuestionnaireWithDisease = async (req, res) => {
  try {
    const { diseaseId } = req.body;

    // Validate if the diseaseId is a valid ObjectId
    if (!mongoose.Types.ObjectId.isValid(diseaseId)) {
      return res.status(400).json({
        status: 'failed',
        message: 'Invalid diseaseId. Please provide a valid ObjectId.',
      });
    }

    // Query the Questionnaire model with the valid ObjectId
    const questionnaires = await Questionnaire.find({ diseaseId });

    // Rest of the code...

    return res.status(200).json({
      status: 'success',
      message: 'Questionnaires for the disease retrieved successfully.',
      data: questionnaires,
    });
  } catch (error) {
    console.log(error);
    return res.status(500).json({
      status: 'failed',
      message: 'An error occurred while fetching questionnaires for the disease.',
    });
  }
};



//// doctor to create appointment
const createAppointment = async (req, res) => {
  const { doctorId, startTime, endTime, date } = req.body;

  try {
    // Validate the input data
    if (!doctorId || !startTime || !endTime || !date || startTime >= endTime) {
      return res.status(400).json({
        status: 'failed',
        message: 'Invalid input data. Please provide valid doctorId, startTime, endTime, and date.',
      });
    }

    // Check if the user making the request is a doctor
    if (!req.user || req.user.role !== 'isDoctor') {
      return res.status(403).json({
        status: 'failed',
        message: 'You do not have permission to create an appointment.',
      });
    }

    // Check if the doctor exists
    const doctor = await Doctor.findById(doctorId);
    if (!doctor) {
      return res.status(404).json({
        status: 'failed',
        message: 'Doctor not found. Please enter a valid doctorId.',
      });
    }

    // Check if the appointment time slot is available
    const availableTimeSlots = doctor.availableTimeSlots;
    const startTime24Hours = moment(startTime).format('HH:mm');
    const endTime24Hours = moment(endTime).format('HH:mm');
    if (!availableTimeSlots.some(
      (slot) => slot.startTime === startTime24Hours && slot.endTime === endTime24Hours
    )) {
      return res.status(400).json({
        status: 'failed',
        message: 'The requested time slot is not available for this doctor.',
      });
    }

    // Create the new appointment without specifying the patient
    const newAppointment = new Appointment({
      doctor: doctorId,
      startTime,
      endTime,
      date, // The raw date provided in the request
      formattedDate: moment(date).format('dddd, DD MMMM, YYYY'), // Formatted date using moment.js
    });

    const savedAppointment = await newAppointment.save();
    // Access the appointment ID after saving
    const appointmentId = savedAppointment._id;

    // Send email to doctor to confirm appointment creation
    const doctorMailOptions = {
      from: process.env.AUTH_EMAIL,
      to: doctor.email,
      subject: 'Appointment Created',
      html: `
        <h1>Appointment Created</h1>
        <p>An appointment has been created for you on ${date} from ${startTime} to ${endTime}.</p>
      `,
    };

    transporter.sendMail(doctorMailOptions, (error, info) => {
      if (error) {
        console.log(error);
      } else {
        console.log('Doctor email sent: ' + info.response);
      }
    });

    return res.status(200).json({
      status: 'success',
      message: 'Appointment created successfully.',
      data: savedAppointment,
      appointmentId: appointmentId, // Return the appointment ID in the response
    });
  } catch (error) {
    console.log(error);
    return res.status(500).json({
      status: 'failed',
      message: 'An error occurred while creating the appointment.',
    });
  }
};


//////SIGN UP USER AS DOCTOR verified
const signUpAsDoctors = async (req, res) => {
  const { email, adminUserId } = req.body;

  try {
    // Check if the user making the request is an admin
    const adminUser = await User.findById(adminUserId);

    if (!adminUser || !adminUser.isAdmin) {
      return res.status(403).json({
        status: 'failed',
        message: 'You do not have permission to sign up doctors.',
      });
    }

    // Check if the user with the given email already exists
    let user = await User.findOne({ email });

    if (user) {
      // If the user exists, update their isDoctor field to true and save the user
      user.isDoctor = true;
      await user.save();

      // Send an email notifying the user that they are now a doctor
      const mailOptions = {
        from: 'Your Email <youremail@gmail.com>',
        to: email,
        subject: 'Congratulations! You are now a doctor',
        html: '<p>You have been verified as a doctor.</p>',
      };

      transporter.sendMail(mailOptions, (error, info) => {
        if (error) {
          console.log('Error sending verification email:', error);
        } else {
          console.log('Verification email sent:', info.response);
        }
      });

      return res.json({
        status: 200,
        message: 'Doctor created successfully.',
      });
    } else {
      // If the user does not exist, create a new user and set their isDoctor field to true
      const doctor = new User({
        email,
        isDoctor: true,
      });

      await doctor.save();

      // Generate a verification token and send it via email
      const verificationToken = jwt.sign(
        { email },
        'your_secret_verification_key', // Replace with your own secret key
        { expiresIn: '1h' }
      );

      const verificationLink = `http://yourdomain.com/verify-doctor?token=${verificationToken}`;

      const mailOptions = {
        from: 'Your Email <youremail@gmail.com>',
        to: email,
        subject: 'Verify Your Doctor Account',
        html: `<p>Please click the link below to verify your doctor account:</p><a href="${verificationLink}">${verificationLink}</a>`,
      };

      transporter.sendMail(mailOptions, (error, info) => {
        if (error) {
          console.log('Error sending verification email:', error);
        } else {
          console.log('Verification email sent:', info.response);
        }
      });

      return res.json({
        status: 200,
        message: 'Verification email sent. Please verify your doctor account.',
      });
    }
  } catch (error) {
    console.log('Error signing up as doctor:', error);
    return res.status(500).json({
      status: 'failed',
      message: 'An error occurred while processing your request.',
    });
  }
};




// Update user information by admin
router.put('/update/:userId', async (req, res) => {
  const { userId } = req.params;
  const { phoneNumber, firstName, lastName } = req.body;

  const result = await userController.updateUserByAdmin(userId, phoneNumber, firstName, lastName);

  if (result.success) {
    return res.status(200).json({
      status: 'success',
      message: result.message,
      data: result.user,
    });
  } else {
    return res.status(500).json({
      status: 'failed',
      message: result.message,
    });
  }
});

module.exports = router;





const express = require('express');
const jwt = require('jsonwebtoken');
const cookieParser = require('cookie-parser');
const User = require('../models/User');
const { AppError } = require('../utilities/createError'); // Import your error handler

const app = express();

app.use(cookieParser());
app.use(express.json()); // Middleware to parse JSON request bodies

// Middleware to verify the token from cookies
const verifyToken = async (req, res, next) => {
  const token = req.cookies.accessToken; // Read the token from cookies

  if (!token) {
    return next(new AppError('Access denied. Token missing.', 401));
  }

  try {
    const decoded = await jwt.verify(token, process.env.JWT_SEC_KEY);
    req.user = decoded.user;
    next();
  } catch (err) {
    return next(new AppError('Invalid token.', 401));
  }
};

// Middleware to verify if the user is a doctor
const verifyDoctor = async (req, res, next) => {
  const userId = req.user.id;

  try {
    const user = await User.findById(userId);
    if (!user || !user.role.includes('isDoctor')) {
      return next(new AppError('User not found or is not authorized as a doctor.', 403));
    }

    next();
  } catch (error) {
    return next(new AppError('An error occurred while processing your request.', 500));
  }
};

const verifyUser = async (req, res, next) => {
  const user = req.user;

  if (!user || !user.role.includes('isUser')) {
    return next(new AppError('User not found or is not authorized.', 403));
  }

  next();
};

const verifyAdmin = async (req, res, next) => {
  const user = req.user;

  if (!user || !user.role.includes('isAdmin')) {
    return next(new AppError('User not found or is not authorized as an admin.', 403));
  }

  next();
};

module.exports = {
  verifyToken,
  verifyDoctor,
  verifyUser,
  verifyAdmin
};